---
title: "5-SOD"
output: html_document
date: "2024-07-10"
---

```{r, eval =TRUE, message=FALSE}
library(knitr)
library(tidyverse)
library(tidyr)
library(dplyr)
library(hrbrthemes)
library(ggplot2)
library(car)
library(RColorBrewer)
library(ggpubr)
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE)
```

# Background
An LC50 determination for nickel on *Botryllus schlosseri* was completed in Spring Quarter 2024. Specimens were snap frozen at the 24 and 96 hour mark to assess for accumulation of Superoxide Dismutase 1 (SOD1). SOD1 is an endogenous antioxidant with a primary function involving the removal of reactive oxygen species (ROS). 

Nickel genotoxicity functions indirectly through the resultant intracellular accumulation of ROS in most animal cells. ROS cause double and single stranded breaks to the DNA which inevitably may result in mutations forming at the cellular attempts to repair the DNA.

Here we explore the effects of increasing concentrations of nickel on the accumulation of SOD1 in *B. schlosseri*.


# Retrieving Data from Google Sheets

## SOD Data

Make sure you have made your Google sheet publicly available to anyone that has the link. If you make any updates to the sheet just re-curl the data, meaning just re-run the code below.

I apologize for not making a relative path. Just modify what is after "tee" to your own directory path.

```{r, engine='bash', eval=FALSE}
cd ..

curl -L https://docs.google.com/spreadsheets/d/1vNxX2tBdEa0Ibyd4mFdru5sAZx0aipv37-y-hkqvJq4/export?exportFormat=csv | tee data/SOD.csv
```
## BCA Data No Raw Absorbance

```{r, engine='bash', eval = FALSE}
cd ..

curl -L https://docs.google.com/spreadsheets/d/1mKhd95gn_tith8fJbYjX3jGyrO-Y4mWKCoCKdTVZFHY/export?exportFormat=csv | tee data/BCA_noRawAbs.csv
```

## BCA Data Raw Absorbance

```{r, engine='bash', eval = FALSE}
cd ..

curl -L https://docs.google.com/spreadsheets/d/180-3tk6UJCAyGFkj0JzIqdBfeG5nf0S4BTjKkK0sou8/export?exportFormat=csv | tee data/BCA_RawAbs.csv
```

## Pierce 660
```{r, engine='bash', eval = FALSE}
cd ..

curl -L https://docs.google.com/spreadsheets/d/1Y7fSSzmRqMN0mAn8XsuSnGjiY0sSJq9Xlz2RJjMxYwM/export?exportFormat=csv | tee data/pierce660_1to4dilution.csv
```


## Metadata

Mostly it has the homogenization number and tunicate ID. We are gonna merge this with the other data frames.

```{r, engine='bash'}
cd ..
curl -L https://docs.google.com/spreadsheets/d/1eDGpgtTB_yBolNCtSxVU2U_oajdm3Oi7guIREc7asRc/export?exportFormat=csv | tee data/metadata.csv
```

## Blastogenic Data
```{r, engine='bash'}
cd ..
curl -L https://docs.google.com/spreadsheets/d/1JtJO3EX06BYK4pYwZZ7b7ZCoTyZcAeuTRka_9kA-yPk/export?exportFormat=csv | tee data/morph.csv
```


## QAQC data

Will need to exclude as they were not processed in assay:
- DM042024_C02 (1 mg/L condition) declined in health.
- DM022024_C05 (control) needs to be redone we have it for the BCA but not the SOD. Ran out of Xan. Ox.  

Results in 8 replicates for 100 mg/L conc. and  7  for the 1 mg/L conc. + control.

Look at the summaries of each data frame and make sure all the data looks right.

Theoretically, we did 8 replicates per treatment and 2 time points. 

Below we want to look at 0, 1, 100 mg/L treatments.

There should be 48 total homogenates we are looking at. Note that the SOD assay has technical duplicates and the BCA assay had technical triplicates of each of those homogenates.

Per treatment there should be:

- 32 "observations" (entries/rows) for the SOD assay 

- 48 "observations" for the BCA assay

# SOD

```{r}
setwd('..')
sod <- read.csv(file = "data/SOD.csv")
```

```{r}
sod_std_key <- tibble::tribble(
  ~standard, ~known_sod_u_ml,
  2, 2,
  3, 1,
  4, 0.5,
  5, 0.25,
  6, 0.125,
  7, 0.0625,
  8, 0
)

sod <- sod %>%
  left_join(
    sod_std_key,
    by = c("homogenate" = "standard")
  ) %>%
  mutate(
    known_sod_u_ml = if_else(type == "standard", known_sod_u_ml, NA_real_)
  )
```

## Calculate SOD from raw absorbance
```{r}
# take the adjusted raw values from pre and post incubation with the xan ox solubalization agent
sod <- sod %>%
  mutate(
    delta_abs = post_xan_ox_abs450 - pre_xan_ox_abs450
  )
```



```{r}
# take the average of each tech rep of the blank (std 8 = 0 u/mL) standard per plate
blank_df <- sod %>%
  filter(type == "standard",
         known_sod_u_ml == 0) %>%
  group_by(plate) %>%
  summarise(blank_delta = mean(delta_abs, na.rm = TRUE), .groups = 'drop')

# put the average blank for each plate in the main sod data frame
sod <- sod %>%
  left_join(blank_df, by="plate")


# here we take the average blank and then do average blank - tech rep of blank <- which is not zero 
# apparently this method of average blank - tech rep of blank is more statistically robust
sod <- sod %>%
  mutate(blank_corrected_abs = delta_abs - blank_delta)


sod %>%
  filter(type == "standard", known_sod_u_ml == 0) %>%
  group_by(plate) %>%
  summarise(
    mean_blank_corrected = mean(blank_corrected_abs, na.rm = TRUE),
    sd_blank_corrected = sd(blank_corrected_abs, na.rm = TRUE),
    .groups = "drop"
  )
# the mean_blank_corrected should be 0 or close to 0
```
## SOD standard curve
```{r}
# create a data frame for only the sod standards
std_df <- sod %>%
  filter(type == "standard",
         !is.na(known_sod_u_ml))

std_df %>%
  select(well_content, known_sod_u_ml, blank_corrected_abs) %>%
  head()

# remove the blank
sod_std_df <- std_df %>%
  filter(type == "standard", known_sod_u_ml > 0)

# now plot the blank-corrected standards 
ggplot(std_df, aes(x = known_sod_u_ml, y = blank_corrected_abs)) +
  facet_wrap(~plate)+
  geom_point(size = 3) +
  theme_classic(base_size = 14) +
  labs(
    x = "Known SOD (U/mL)",
    y = "Blank-corrected ΔA450"
  )

```


## line of best fit for std
```{r}

sod_coefs <- sod_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(blank_corrected_abs ~ log(known_sod_u_ml), data = .)
    tibble(
      a_coef_sod = coef(fit)[1],
      b_coef_sod = coef(fit)[2]
    )
  }) %>%
  ungroup()

sod <- sod %>%
  left_join(sod_coefs, by = "plate")

# visual confirmation of line of best fit
# make smooth x values for plotting lines
sod_lines <- sod_coefs %>%
  crossing(
    known_sod_u_ml = seq(
      min(std_df$known_sod_u_ml[std_df$known_sod_u_ml > 0]),
      max(std_df$known_sod_u_ml),
      length.out = 200
    )
  ) %>%
  mutate(
    pred_abs = a_coef_sod + b_coef_sod * log(known_sod_u_ml)
  )

ggplot(std_df, aes(x = known_sod_u_ml, y = blank_corrected_abs)) +
  facet_wrap(~plate) +
  geom_point(size = 3) +
  geom_line(
    data = sod_lines,
    aes(x = known_sod_u_ml, y = pred_abs),
    color = "red",
    linewidth = 1
  ) +
  theme_classic(base_size = 14) +
  labs(
    x = "Known SOD (U/mL)",
    y = "Blank-corrected ΔA450"
  )

```

## SOD Calculation in R
```{r}
sod <- sod %>%
  mutate(
    sod_u_ml_calc = exp((blank_corrected_abs - a_coef_sod) / b_coef_sod)
  )

# adjust by dilution factor to get final sod concentration 
sod <- sod %>%
  mutate(
    dilution_n = as.numeric(str_match(dilution_factor_unknownsample_pbs, "1:(\\d+(?:\\.\\d+)?)")[,2]),
    sod_u_ml_final = if_else(
      type == "unknown" & !is.na(dilution_n),
      sod_u_ml_calc * dilution_n,
      sod_u_ml_calc
    )
  )
```

Check that the model fit our data correctly 
```{r}

sod_summary <- sod %>%
  filter(type == "unknown") %>%
  group_by(plate, homogenate) %>%
  summarise(
    mean_sod = mean(sod_u_ml_final, na.rm = TRUE),
    sd_sod = sd(sod_u_ml_final, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )

```

```{r}
setwd( '..' )
write.csv(sod, "data/sod_all_wells_with_calculatedR_activity.csv", row.names = FALSE)
write.csv(sod_summary, "data/sod_homogenate_meansR.csv", row.names = FALSE)
```



# BCA
```{r}
setwd('..')
bca_raw <- read.csv(file = "data/BCA_RawAbs.csv")
bca_noRaw <-read.csv(file = "data/BCA_noRawAbs.csv")

bca <- full_join(bca_noRaw, bca_raw, by = c("well_content", "plate", "type", "assay_date", "assay"))

# extract the standard name and place in the homogenate column
bca <- bca %>%
  mutate(
    homogenate = as.character(homogenate),
    homogenate = if_else(
      type == "standard",
      str_extract(well_content, "^[A-Za-z]"),
      homogenate
    )
  )
```

## BCA standard curve
```{r}
# create a standard key
bca_std_key <- tibble::tribble(
  ~standard, ~known_mg_ml,
  "A", 0,
  "B", 0.1,
  "C", 0.2,
  "D", 0.4,
  "E", 0.8,
  "F", 1.2,
  "G", 1.6,
  "H", 2
)

bca <- bca %>%
  left_join(bca_std_key, by = c("homogenate" = "standard")) %>%
  mutate(known_mg_ml = if_else(type == "standard", known_mg_ml, NA_real_))



```


calculate the average blank absorbance value for each plate
```{r}
bca_blank_df <- bca %>%
  filter(type == "standard", known_mg_ml == 0) %>%   # 'A' standard
  group_by(plate) %>%
  summarise(bca_blank_abs = mean(abs562, na.rm = TRUE), .groups = "drop")

```
add that average blank absorbance value and the blank corrected absorbance value for each unknown homogenate
```{r}
bca <- bca %>%
  left_join(bca_blank_df, by = "plate") %>%
  mutate(abs562_blankcorr = abs562 - bca_blank_abs)
```

```{r}
# make sure to drop the na for standard D tech rep 3 of plate 1
bca_std_df <- bca %>%
  filter(type == "standard", !is.na(known_mg_ml)) %>%
  filter(!is.na(abs562), !is.na(abs562_blankcorr))


ggplot(bca_std_df, aes(x = known_mg_ml, y = abs562_blankcorr)) +
  facet_wrap(~plate) +
  geom_point(size = 3) +
  geom_smooth(method = "lm",
              formula = y ~ 0 + x,
              se = FALSE,
              color = "blue",
              linewidth = 1.2) +
  theme_classic(base_size = 14) +
  labs(
    x = "BSA standard (mg/mL)",
    y = "Blank-corrected absorbance @562"
  )

```


Create a linear model to fit standard and unknown data
```{r}
bca_coefs <- bca_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(abs562_blankcorr ~ 0 + known_mg_ml, data = .)
    tibble(b_slope_bca = coef(fit)[1])
  }) %>%
  ungroup()

bca_coefs

bca <- bca %>%
  left_join(bca_coefs, by = "plate")


```

```{r}
bca <- bca %>%
  mutate(
    protein_mg_ml_calc = abs562_blankcorr / b_slope_bca,
    protein_mg_ml_final = if_else(
      type == "unknown",
      protein_mg_ml_calc * 4,   # your 1:4 dilution
      protein_mg_ml_calc        # standards: leave as-is
    )
  )


bca %>%
  filter(type=="standard") %>%
  select(homogenate, known_mg_ml, protein_mg_ml_calc) %>%
  arrange(known_mg_ml)
# the protien calc should match that of the known standards

bca %>%
  filter(type=="standard") %>%
  ggplot(aes(x = known_mg_ml, y = protein_mg_ml_calc)) +
  facet_wrap(~plate)+
  geom_point(size=3) +
  geom_abline(slope=1, intercept=0, linetype="dashed", color="red") +
  theme_classic() +
  labs(x="True mg/mL", y="Calculated mg/mL")
```

```{r}
bca_fit_stats <- bca_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(abs562_blankcorr ~ 0 + known_mg_ml, data = .)
    s <- summary(fit)

    tibble(
      slope = coef(fit)[1],
      r_squared = s$r.squared,
      adj_r_squared = s$adj.r.squared,
      residual_se = s$sigma
    )
  }) %>%
  ungroup()

```

```{r}
# coefficients per plate (with intercept) comapre for sanity check that we should force the model through (0,0)
bca_coefs_intercept <- bca_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(abs562_blankcorr ~ known_mg_ml, data = .)
    tibble(
      intercept = coef(fit)[1],
      slope     = coef(fit)[2]
    )
  }) %>%
  ungroup()

bca_fit_stats_intercept <- bca_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(abs562_blankcorr ~ known_mg_ml, data = .)
    s <- summary(fit)

    tibble(
      intercept     = coef(fit)[1],
      slope         = coef(fit)[2],
      r_squared     = s$r.squared,
      adj_r_squared = s$adj.r.squared,
      residual_se   = s$sigma
    )
  }) %>%
  ungroup()
# the model through (0,0) has higher R squared values. retain all calculations for protein per mg using that modelcalculated
```


take the averages per homogenate

```{r}
bca_summary <- bca %>%
  filter(type == "unknown") %>%
  mutate(homogenate = as.numeric(homogenate)) %>%
  group_by(plate, homogenate) %>%
  summarise(
    mean_protein_mg_ml = mean(protein_mg_ml_final, na.rm = TRUE),
    sd_protein_mg_ml   = sd(protein_mg_ml_final, na.rm = TRUE),
    n = sum(!is.na(protein_mg_ml_final)),
    .groups = "drop"
  )


```





# Pierce
```{r}
setwd('..')
pierce <- read.csv("data/pierce660_1to4dilution.csv")
```
```{r}
pierce_std_key <- tibble(
  std_id = c("PBS","A","B","C","D","E","F","G"),
  known_ug_ml = c(0, 125, 250, 500, 750, 1000, 1500, 2000)
) %>%
  mutate(known_mg_ml = known_ug_ml / 1000)

#extract homogenaate, tech rep, and dilution factor from the well_content column
pierce <- pierce %>%
  mutate(
    type = if_else(str_detect(well_content, "^Hom\\s"), "unknown", "standard"),
    homogenate = if_else(
      type == "unknown",
      as.numeric(str_match(well_content, "^Hom\\s+(\\d+)")[,2]),
      NA_real_
    ),
    tech_rep = str_match(well_content, "(R\\d+)")[,2],
    dilution_factor_unknownsample_pbs = str_match(well_content, "(1:\\d+)")[,2],
    std_id = if_else(
      type == "standard",
      str_match(well_content, "\\b(PBS|A|B|C|D|E|F|G)\\b")[,2],
      NA_character_
    )
  ) %>%
  left_join(pierce_std_key, by = "std_id") # add in the id names for the standards

pierce %>% filter(type=="standard") %>% count(std_id) # check we have 3 from each plate

```
blank correction using PBS wells for each plate
```{r}
pierce_blank_df <- pierce %>%
  filter(type == "standard", std_id == "PBS") %>%
  group_by(plate) %>%
  summarise(pierce_blank_abs = mean(absorbance_660, na.rm = TRUE), .groups = "drop")

pierce <- pierce %>%
  left_join(pierce_blank_df, by = "plate") %>%
  mutate(abs660_blankcorr = absorbance_660 - pierce_blank_abs)

```

create standard curve for pierce assay
```{r}
pierce_std_df <- pierce %>%
  filter(type == "standard") %>%
  drop_na(known_mg_ml, abs660_blankcorr)

pierce_coefs <- pierce_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(abs660_blankcorr ~ 0 + known_mg_ml, data = .)
    tibble(
      slope = coef(fit)[1]
    )
  }) %>%
  ungroup()

```
let's check the fit of our model to each plate

```{r}
pierce_fit_stats <- pierce_std_df %>%
  group_by(plate) %>%
  do({
    fit <- lm(abs660_blankcorr ~ 0 + known_mg_ml, data = .)
    s <- summary(fit)

    tibble(
      slope = coef(fit)[1],
      r_squared = s$r.squared,
      adj_r_squared = s$adj.r.squared,
      residual_se = s$sigma
    )
  }) %>%
  ungroup()

pierce_fit_stats


pierce_lines <- pierce_coefs %>%
  crossing(
    known_mg_ml = seq(
      min(pierce_std_df$known_mg_ml),
      max(pierce_std_df$known_mg_ml),
      length.out = 200
    )
  ) %>%
  mutate(pred_abs = slope * known_mg_ml)

ggplot(pierce_std_df, aes(x = known_mg_ml, y = abs660_blankcorr)) +
  facet_wrap(~plate) +
  geom_point(size = 3) +
  geom_line(
    data = pierce_lines,
    aes(x = known_mg_ml, y = pred_abs),
    color = "blue",
    linewidth = 1.2
  ) +
  theme_classic(base_size = 14) +
  labs(
    x = "Protein (mg/mL)",
    y = "Blank-corrected Abs 660"
  )

```


```{r}
pierce <- pierce %>%
  left_join(pierce_coefs, by = "plate")

pierce <- pierce %>%
  mutate(
    protein_mg_ml_calc = abs660_blankcorr / slope,
    protein_mg_ml_final = if_else(
      dilution_factor_unknownsample_pbs == "1:4",
      protein_mg_ml_calc * 4,
      protein_mg_ml_calc
    )
  )


```

```{r}
pierce_summary <- pierce %>%
  filter(type == "unknown") %>%
  mutate(homogenate = as.numeric(homogenate)) %>%
  group_by(plate, homogenate) %>%
  summarise(
    mean_protein_mg_ml = mean(protein_mg_ml_final, na.rm = TRUE),
    sd_protein_mg_ml   = sd(protein_mg_ml_final, na.rm = TRUE),
    n = sum(!is.na(protein_mg_ml_final)),
    .groups = "drop"
  )

#flag homogenates that fell below pierce detection limit
pierce_summary <- pierce_summary %>%
  mutate(
    protein_flag_low = mean_protein_mg_ml <= 0
  )
```


#Blastogenic stage & metadata
```{r}
setwd('..')
blast <- read.csv("data/LC50.csv")
```

5 time points * 8 replicates

Should be 40 entries per concentration (over 40 is ok)

```{r}
blast <- blast %>% 
  mutate(hpe = as.factor(hpe)) %>%
  mutate(NiCl2.Nom.Conc. = as.factor(NiCl2.Nom.Conc.))

head(blast)
summary(blast)
```

```{r}
setwd('..')
metadata <- read.csv("data/metadata.csv")
```

In the BCA and SOD data frame, we are missing the hpe associated with the each sample. We can add this on to a new data frame that also combines it with the SOD data after we take the averages and standard errors of the technical replicates of the BCA assay.

::: {.callout-note}
Note that as of July 3, 2024, the data set for the 10 mg/L is incomplete in this data frame and should be taken with a grain of salt or removed from the data frame below. The 0 mg/L treatment is also incomplete with homogenate 37 needing to be re-evaluated.
:::



#Data Munging to combine data frames!

Modify SOD metadata to merge with other data frames more easily
```{r}
metadata <- metadata %>%
  rename(homogenate = hom_num) %>%   # rename column first
  select(homogenate, Tunicate.ID, date, hpe, NiCl2.Nom.Conc., true_rep, rep_exp) %>%
  mutate(NiCl2.Nom.Conc. = as.factor(NiCl2.Nom.Conc.)) %>%
  mutate(hpe = as.factor(hpe)) %>%
  mutate(homogenate = as.factor(homogenate))

summary(metadata)

metadata2 <- metadata %>%
  mutate(homogenate = as.numeric(as.character(homogenate))) # change to numeric for merging data frames

```

::: {.callout-note}
The column sod_avg is in activity units/mL and the column bca_avg is in mg/mL.
:::

```{r}
assay_combo <- bca_summary %>%
  # rename BCA protein column before joining
  rename(
    bca_mean_protein_mg_mL = mean_protein_mg_ml,
    bca_sd_protein_mg_mL   = sd_protein_mg_ml,
    n_bca                  = n,
    plate_bca              = plate
  ) %>%
  full_join(
    sod_summary %>%
      rename(
        n_sod     = n,
        plate_sod = plate
      ),
    by = "homogenate"
  ) %>%
  full_join(
    pierce_summary %>%
      rename(
        pierce_mean_protein_mg_mL = mean_protein_mg_ml,
        pierce_sd_protein_mg_mL   = sd_protein_mg_ml,
        n_pierce                  = n,
        plate_pierce              = plate
      ),
    by = "homogenate"
  ) 



```

calculate sod per mg of protein for each asay

```{r}
assay_combo <- assay_combo %>%
  mutate(
    sod_u_mg_bca = mean_sod / bca_mean_protein_mg_mL,
    sod_u_mg_pierce = mean_sod / pierce_mean_protein_mg_mL
  )

```

given that we did a 1:4 dilution of the pierce assay, it likely is that the values calculated here are unreliable. plate 2 is particulary unreliable given the spread of the data in the standard curve

flag the outliers 
```{r}
assay_combo <- assay_combo %>%
  mutate(
    pierce_flag_unreliable = pierce_mean_protein_mg_mL < 0.01
  )
```


```{r}
combo_metadata <- assay_combo %>%
  full_join(metadata2, by = "homogenate")
```

ok combine with blastogenic data
```{r}
combo <- combo_metadata %>%
  left_join(
    blast,
    by = c("Tunicate.ID", "NiCl2.Nom.Conc.", "hpe")
  )
```

```{r}
combo <- combo %>%
  filter(!is.na(sod_u_mg)) %>%
  filter(NiCl2.Nom.Conc. != 10) 
summary(combo)
```
```{r}
combo <- combo %>%
  mutate(simple_stage = case_when(
    stage %in% c("A1", "A2") ~ "A",
    stage %in% c("B1", "B2") ~ "B",
    stage %in% c("C1", "C2") ~ "C",
    stage == "D" ~ "D",
    TRUE ~ NA_character_  # This will handle any other cases or return NA if none match
  )) %>%
    mutate(simple_stage = as.factor(simple_stage))

summary(combo)
```

```{r}
combo24 <- combo %>%
  filter(hpe == 24)

combo96 <- combo %>%
  filter(hpe == 96)

summary(combo24)
summary(combo96)
```





# Exploratory Plots
```{r}

ggplot(combo24, aes(x = NiCl2.Nom.Conc., y = sod_u_mg, fill = hpe)) +
  geom_point() +
  geom_violin(trim = FALSE) +
  facet_wrap(~ simple_stage) +
  labs(title = "Violin Plot of SOD Activity (u/mL) at 24 hpe by Treatment and stage",
       fill = "HPE",
       x = "Treatment",
       y = "SOD Activity") 

```

```{r}

ggplot(combo96, aes(x = NiCl2.Nom.Conc., y = sod_u_mg, fill = hpe)) +
  geom_point() +
  geom_violin(trim = FALSE) +
  facet_wrap(~ simple_stage) +
  labs(title = "Violin Plot of SOD Activity (u/mL) by Treatment and stage",
       fill = "HPE",
       x = "Treatment",
       y = "SOD Activity") 
```

```{r}

ggplot(combo, aes(x = NiCl2.Nom.Conc., y = sod_u_mg, fill = hpe)) +
  geom_point() +
  geom_violin(trim = FALSE) +
  facet_wrap(~ simple_stage, ncol=2) +
  labs(title = "Violin Plot of SOD Activity (u/mL) by Treatment and hpe and stage",
       fill = "HPE",
       x = "Treatment",
       y = "SOD Activity") 
```



"Oxidative stress does change with the blastogenic stage of Botryllus schlosseri naturally. Botryllus schlosseri, a colonial ascidian, undergoes a cyclic process called blastogenesis, which includes different stages: bud formation, growth, and take-over (zooid death and replacement by a new generation). During these stages, physiological and biochemical changes occur, including variations in oxidative stress levels."


Note that the plot below is the unormalized data. A BCA was run on the samples as well to quantify total protein content.
```{r, eval=TRUE}
ggplot(combo, aes(x = NiCl2.Nom.Conc., y = mean_sod, fill = NiCl2.Nom.Conc.)) +
  geom_point() +
  geom_violin(trim = FALSE) +
  facet_wrap(~ hpe, scales = "free_y") +
  labs(title = "Violin Plot of SOD Activity (u/mL) by Treatment and HPE",
       fill = "Nickel Concentration",
       x = "Treatment",
       y = "SOD Activity") 
```

## SOD1 activity normalized to the protein content per sample:
```{r, eval=TRUE}

ggplot(combo, aes(x = NiCl2.Nom.Conc., y = sod_u_mg, fill = hpe)) +
  geom_violin(trim = FALSE)  +
  labs(title = "Violin Plot of SOD Activity (u/mg) by Nickel and hpe",
       x = "Nickel Concnetration mg/L",
       y = "SOD Activity") 
```



## compares stage
```{r}

# Ensure concentrations plot in numeric order (but treated as discrete groups)
combo_plot <- combo %>%
  mutate(
    NiCl2.Nom.Conc. = factor(NiCl2.Nom.Conc.,
                             levels = sort(unique(as.numeric(as.character(NiCl2.Nom.Conc.))))),
    hpe = factor(hpe)
  )

n_counts <- combo_plot %>%
  group_by(hpe, NiCl2.Nom.Conc.) %>%
  summarise(n = n(), .groups = "drop")

```

# Violin with all points
```{r}

ggplot(combo_plot, aes(x = NiCl2.Nom.Conc., y = sod_u_mg)) +
  geom_violin(trim = FALSE, width = 0.9, alpha = 0.6) +
  geom_jitter(width = 0.12, height = 0, size = 3, alpha = 0.9) +
  # Median dot per group
  stat_summary(fun = median, geom = "point", size = 4, color="blue") +
  # Optional: median line inside each violin
  stat_summary(fun = median, geom = "crossbar", width = 0.6, fatten = 0) +
  facet_wrap(~ hpe, nrow = 1) +
  scale_y_continuous(breaks = seq(0, 5, by = 1), limits = c(0, 5), expand = c(0.2, 0)) +
  labs(x = "Nickel (II) Chloride Concentration (mg/L)", y = "SOD1 (U/mg)") +
  geom_text(
  data = n_counts,
  aes(x = NiCl2.Nom.Conc., y = 0, label = paste0("n=", n)),
  vjust = 1.5,
  size = 6,
  inherit.aes = FALSE
)+
  theme_minimal(base_size = 18) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey50"),
    panel.grid.minor.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    panel.background = element_rect(fill = "white", color = "white"),
    plot.background  = element_rect(fill = "white", color = "white"),
    axis.text = element_text(size = 18),
    axis.title = element_text(size = 20),
    axis.text.y = element_text(hjust = 1.2, margin = margin(r = 10)),
    axis.text.x = element_text(vjust = 2, margin = margin(t = 10))
  )



```
# Just boxplot, Final Figure 

```{r}
str(combo_plot)
```


```{r}
png(filename = "../output/boxplot_sod_RnormalizedBCA.png", width = 1300, height = 850)
ggplot(combo_plot, aes(x = NiCl2.Nom.Conc., y = sod_u_mg)) +
  geom_boxplot(width = 0.7, outlier.shape = 5, alpha = 0.6) +
  geom_jitter(width = 0.01, height = 0, size = 4, alpha = 0.9,
              aes(color = simple_stage)) +
  stat_summary(fun = mean, geom = "point", size = 4, color="blue") +
  facet_wrap(~ hpe, nrow = 1,
             labeller = labeller(
    hpe = function(x) paste0(x, " hpe"))) +
  scale_y_continuous(breaks = seq(0, 5, by = 0.5), limits = c(0, 5), expand = c(0.05, 0.1)) +
  labs(x = "Nickel (II) Chloride Concentration (mg/L)", 
       y = "SOD1 Activity (U/mg protein)",
       color = "Stage") +
  geom_text(
  data = n_counts,
  aes(x = NiCl2.Nom.Conc., y = 0, label = paste0("n=", n)),
  vjust = 1.5,
  size = 8,
  inherit.aes = FALSE
)+
  theme_minimal(base_size = 18) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "white"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    panel.background = element_rect(fill = "white", color = "grey"),
    plot.background  = element_rect(fill = "white", color = "white"),
    strip.background = element_rect(fill = "grey"),
    strip.text = element_text(size = 28, face = "bold"),
    axis.text = element_text(size = 18),
    axis.title = element_text(size = 30),
    axis.text.y = element_text(hjust = 1.2, margin = margin(r = 10), size = 25),
    axis.text.x = element_text(vjust = 2, margin = margin(t = 10), size =25)
  )
dev.off()
```


```{r}
png(filename = "../output/boxplot_sod_RnormalizedBCA_alt.png", width = 1300, height = 850)
ggplot(combo_plot, aes(x = NiCl2.Nom.Conc., y = sod_u_mg)) +

  # boxplot
  geom_boxplot(width = 0.65, outlier.shape = NA, alpha = 0.5, color = "black") +

  # raw points colored by stage
  geom_jitter(
    aes(color = simple_stage),
    width = 0.12, height = 0,
    size = 3.5, alpha = 0.9
  ) +

  # mean diamond
  stat_summary(
    fun = mean,
    geom = "point",
    shape = 18,        # diamond
    size = 6,
    color = "blue"
  ) +


  facet_wrap(~ hpe, nrow = 1,
             labeller = labeller(hpe = function(x) paste0(x, " hpe"))) +

  scale_y_continuous(
    breaks = seq(0, 4, by = 0.5),
    limits = c(0, 4),
    expand = c(0.02, 0.02)
  ) +

  labs(
    x = "Nominal Nickel (II) Chloride Concentration (mg/L)",
    y = "SOD1 Activity (U/mg protein)",
    color = "Blastogenic stage"
  ) +

  # n labels
  geom_text(
    data = n_counts,
    aes(x = NiCl2.Nom.Conc., y = 0.05, label = paste0("n=", n)),
    size = 6,
    inherit.aes = FALSE
  ) +

  # color palette (softer & professional)
  scale_color_brewer(palette = "Dark2") +

  theme_classic(base_size = 18) +
  theme(
    strip.text = element_text(size = 22, face = "bold"),
    axis.title = element_text(size = 22),
    axis.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.position = "right",
    panel.background = element_rect(fill = "white", color = "black"),
    legend.key = element_rect(fill = "white", color = NA)
  )
dev.off()
```


combine them (boxplot + violin)
```{r}
ggplot(combo_plot, aes(x = NiCl2.Nom.Conc., y = sod_u_mg)) +
    geom_violin(trim = FALSE, width = 0.9, alpha = 0.6) +
  geom_boxplot(width = 0.7, outlier.shape = NA, alpha = 0.6) +
  geom_jitter(width = 0.12, height = 0, size = 3, alpha = 0.9) +
  stat_summary(fun = median, geom = "point", size = 4, color="blue") +
  facet_wrap(~ hpe, nrow = 1) +
  scale_y_continuous(breaks = seq(0, 40, by = 10), limits = c(0, 40)) +
  labs(x = "Nickel (II) Chloride Concentration (mg/L)", y = "SOD1 (U/mg)") +
  theme_minimal(base_size = 18) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    strip.background = element_rect(fill = "grey", color = "grey"),
    panel.background = element_rect(fill = "white", color = "black"),
    plot.background  = element_rect(fill = "white", color = "grey"),
    axis.text = element_text(size = 18),
    axis.title = element_text(size = 20),
    axis.text.y = element_text(hjust = 1.2, margin = margin(r = 10)),
    axis.text.x = element_text(vjust = 2, margin = margin(t = 10))
  )
```







# Statistical Analysis

We will run a two-way ANOVA on the data exploring sod1 activity units/mg of protein by hours post exposure and nickel concentration.

```{r}
# Perform ANOVA
anova_result <- aov(sod_u_mg ~ hpe * NiCl2.Nom.Conc., data = combo)

# Summarize ANOVA results
summary(anova_result)
```

## ANOVA assumptions

```{r}
# Check histogram of transformed data
hist(combo$sod_u_mg, main = "Distribution", xlab = "SOD U/mg")

# Check normality of data (optional)
shapiro.test(combo$sod_u_mg)

# Perform Levene's test on data
leveneTest(sod_u_mg ~ NiCl2.Nom.Conc., data = combo)
```

```{r}
library(car)
# make sure factors are factors
combo <- combo %>%
  mutate(
    hpe = factor(hpe),
    NiCl2.Nom.Conc. = factor(NiCl2.Nom.Conc.)
  )

fit <- lm(sod_u_mg ~ hpe * NiCl2.Nom.Conc., data = combo)

# ANOVA table (base)
anova(fit)

# Better for unbalanced designs:
Anova(fit, type = 2)   # or type = 3 if you *really* need it (see note below)

```

```{r}
# Normality of residuals
shapiro.test(resid(fit))

# Homogeneity of variance across cells (hpe x conc)
car::leveneTest(resid(fit) ~ interaction(hpe, NiCl2.Nom.Conc.), data = combo)

# Plots you should actually look at
par(mfrow=c(1,2))
plot(fit, which = 1)  # residuals vs fitted
plot(fit, which = 2)  # QQ plot
par(mfrow=c(1,1))

```

```{r}
library(emmeans)

emm <- emmeans(fit, ~ NiCl2.Nom.Conc. | hpe)

pairs(emm, adjust = "tukey")

```


## ANOVA Conclusions

Two-way ANOVA detected a significant main effect of nickel concentration on SOD activity (F₂,₃₉ = 3.47, p = 0.041), while no effect of time (p = 0.193) or interaction between time and concentration (p = 0.525) was observed.

Post-hoc Tukey–Kramer comparisons conducted within each timepoint indicated no differences among concentrations at 24 hpe (all p > 0.39). At 96 hpe, SOD activity at 1 mg/L was elevated relative to controls, though this difference did not reach statistical significance after multiple-comparison correction (p = 0.054). No differences were detected between 100 mg/L and other concentrations.


## Power Analysis
Currently this will only work below if the groups are of equal sample size. Because I have yet to re-process the homogenate 37 (the final replicate for the control) this analysis cannot work.

```{r}
library(pwr)
anova_result <- aov(sod_u_mg ~ hpe * NiCl2.Nom.Conc., data = combo)
summary_result <- summary(anova_result)

# Extract the sum of squares
ss_total <- sum(summary_result[[1]][, "Sum Sq"])
ss_residual <- summary_result[[1]]["Residuals", "Sum Sq"]

# Calculate eta squared
eta_squared <- 1 - (ss_residual / ss_total)

# Calculate effect size f
effect_size_f <- sqrt(eta_squared / (1 - eta_squared))
```

```{r}
# Number of groups in your ANOVA (e.g., hpe * treatment)
num_groups <- length(unique(combo$hpe)) * length(unique(combo$NiCl2.Nom.Conc.))

# Significance level (commonly set to 0.05)
alpha <- 0.05

# Sample size (total number of observations)
sample_size <- nrow(combo)

# Conduct power analysis
power_analysis <- pwr.anova.test(k = num_groups, f = effect_size_f, sig.level = alpha, n = sample_size / num_groups)

# Print the result
print(power_analysis)

```
Note that n = 7.5 is in relation to the unequal sample sizes per group which is in relation to the missing control sample, homogenate 37.

Power (0.1781299): The power of 0.1238 indicates that this study has a low probability (approximately 17.8%) of detecting the true effect (f = 0.2437383) under the current conditions (sample sizes, effect size, and significance level).

Considerations: To increase power, we may need to consider increasing the sample size per group, using more sensitive measures, or adjusting your study design to reduce variability.

# DO NOT USE this plot for THESIS Fancy way of doing paired t-test and pholmes adjusted done in plot, do not use for thesis
```{r}

#library(ggstatsplot)

#setwd('..')
#png(filename = "output/violin_sod_hompcorrection_comparetreatments.png", width = 1800, height = 1800)
#grouped_ggbetweenstats(
#  data = combo,
#  x = NiCl2.Nom.Conc.,
#  y = sod_u_mg,
#  grouping.var = hpe,
#  type = "parametric",
#  outlier.tagging = TRUE,
#  xlab = "Nominal NiCl2 (mg/L)",
# ylab = "SOD1 U/mg of protein",
#  pairwise.display = "all",
# results.subtitle = FALSE,
# p.adjust.method = "holm", #does not have an option to show p-vlaues calculated with tukey
#  digits = 2L,
#  package = "wesanderson", ## package from which color palette is to be taken
#  palette = "Moonrise3",  
#   ggsignif.args = list(
#    textsize = 10,      # this controls the text size of the pairwise comparisons
#    tip_length = 0.1,
#    step_increase = 0.2
#  ),
#  annotation.args = list(
#    tag_levels = 'A',
#    theme = theme(plot.title = element_text(size = 40),
#                  plot.tag_levels = element_text(size = 40))
#  ),
#  point.args = list(
#    alpha = 1,
#    size = 10),
#  centrality.point.args = list(size = 10, color = "orangered3"),
#  centrality.label.args = list(
#    alpha = 0,
#    size  = 9, 
#    nudge_x = 0.5, 
#    nudge_y = 9),
#  ggplot.component = list (
#    ggplot2::scale_y_continuous(
#    breaks = seq(0, 5, by = 0.5),
#    limits = (c(0, 5))),
#    theme(
#    axis.ticks = element_blank(),
#    axis.line = element_line(colour = "grey50"),
#    panel.grid = element_line(color = "#b4aea9"),
#    panel.grid.minor = element_blank(),
#    panel.grid.major.x = element_blank(),
#    panel.grid.major.y = element_line(linetype = "dashed"),
#    panel.background = element_rect(fill = "white", color = "white"),
#    plot.background = element_rect(fill = "white", color = "white"),
#    axis.text = element_text(size = 30),   # Adjust the size of the axis labels
#    axis.title = element_text(size = 40),
#    strip.text = element_text(size = 40),
#    axis.text.y = element_text(size = 30, hjust = 1.5, margin = margin(r = 20)),
#    axis.text.x = element_text(size = 30, vjust = 3, hjust = 0.5, margin = margin(t = 20))
#  )
# ) 
#) 
#dev.off()

```

